# goit-algo-hw-05

### **Опис домашнього завдання** [](https://textbook.edu.goit.global/lms-neoversity-homework/uk/docs/basic-algorithms-and-data-tructures/hw-05/#%D0%BE%D0%BF%D0%B8%D1%81-%D0%B4%D0%BE%D0%BC%D0%B0%D1%88%D0%BD%D1%8C%D0%BE%D0%B3%D0%BE-%D0%B7%D0%B0%D0%B2%D0%B4%D0%B0%D0%BD%D0%BD%D1%8F "Direct link to heading")

**Завдання 1**

Додати метод `delete` для видалення пар ключ-значення таблиці `HashTable` , яка реалізована в конспекті.

**Завдання 2**

Реалізувати двійковий пошук для відсортованого масиву з дробовими числами. Написана функція для двійкового пошуку повинна повертати кортеж, де першим елементом є кількість ітерацій, потрібних для знаходження елемента. Другим елементом має бути "верхня межа" — це найменший елемент, який є більшим або рівним заданому значенню.

**Завдання 3**

Порівняти ефективність алгоритмів пошуку підрядка: Боєра-Мура, Кнута-Морріса-Пратта та Рабіна-Карпа на основі двох текстових файлів ([стаття 1](https://drive.google.com/file/d/18_R5vEQ3eDuy2VdV3K5Lu-R-B-adxXZh/view?usp=sharing), [стаття 2](https://drive.google.com/file/d/13hSt4JkJc11nckZZz2yoFHYL89a4XkMZ/view?usp=sharing)). Використовуючи **`timeit`**, треба виміряти час виконання кожного алгоритму для двох видів підрядків: одного, що дійсно існує в тексті, та іншого — вигаданого (вибір підрядків за вашим бажанням). На основі отриманих даних визначити найшвидший алгоритм для кожного тексту окремо та в цілому.

### (1й) Боєр-Мур


|           | Патерн                                                                                          | Big-O Нотація | Час (секунди) | Результат |
| ----------- | ------------------------------------------------------------------------------------------------------- | ---------------------- | ------------------------- | -------------------- |
| Article 1 | Розглянемо деякі реалізації відомих алгоритмів пошуку | O(n)                 | 0.000107                | Так (2596)      |
| Article 1 | Програмна реалізація досліджених структур даних            | O(n)                 | 0.000304                | Ні (-1)          |
| Article 2 | Розглянемо деякі реалізації відомих алгоритмів пошуку | O(n)                 | 0.000369                | Ні (-1)          |
| Article 2 | Програмна реалізація досліджених структур даних            | O(n)                 | 0.000142                | Так (5126)      |

### (2й) Кнут-Морріс-Пратт


|           | Патерн                                                                                          | Big-O Нотація | Час (секунди) | Результат |
| ----------- | ------------------------------------------------------------------------------------------------------- | ---------------------- | ------------------------- | -------------------- |
| Article 1 | Розглянемо деякі реалізації відомих алгоритмів пошуку | O(n + m)             | 0.000477                | Так (2596)      |
| Article 1 | Програмна реалізація досліджених структур даних            | O(n + m)             | 0.001972                | Ні (-1)          |
| Article 2 | Розглянемо деякі реалізації відомих алгоритмів пошуку | O(n + m)             | 0.002807                | Ні (-1)          |
| Article 2 | Програмна реалізація досліджених структур даних            | O(n + m)             | 0.000751                | Так (5126)      |

### (3й) Рабін-Карп


|           | Патерн                                                                                          | Big-O Нотація                                  | Час (секунди) | Результат |
| ----------- | ------------------------------------------------------------------------------------------------------- | ------------------------------------------------------- | ------------------------- | -------------------- |
| Article 1 | Фундаментальні знання допомагають дізнатися                   | ± O(n + m) → O(nm) у гіршому випадку | 0.001098                | Так (2596)      |
| Article 1 | Програмна реалізація досліджених структур даних            | ± O(n + m) → O(nm) у гіршому випадку | 0.004450                | Ні (-1)          |
| Article 2 | Розглянемо деякі реалізації відомих алгоритмів пошуку | ± O(n + m) → O(nm) у гіршому випадку | 0.005952                | Ні (-1)          |
| Article 2 | Програмна реалізація досліджених структур даних            | ± O(n + m) → O(nm) у гіршому випадку | 0.001741                | Так (5126)      |

**Висновок**

Перше місце посів алгоритм `Боєр-Мур` -> `O(n)`.

Друге місце посів алгоритм `Кнут-Морріс-Пратт` -> `O(n + m)`.

Третє місце посів алгоритм `Рабін-Карп` -> `O(n + m)` та `O(nm)` у гіршому випадку.
